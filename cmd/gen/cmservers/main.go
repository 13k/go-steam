package main

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"text/template"
)

const (
	apiURL = "https://api.steampowered.com/ISteamDirectory/GetCMList/v1/?cellid=0&format=json"

	srcCMServers = `// Code generated by cmservers. DO NOT EDIT.

package {{.Package}}

// CMServers contains a list of worlwide servers
var CMServers = []string{
	{{- range .Servers }}
	"{{.}}",
	{{- end }}
}
`
)

var (
	tplCMServers = template.Must(template.New("cmservers").Option("missingkey=error").Parse(srcCMServers))
)

type apiResult struct {
	Response apiResponse `json:"response"`
}

type apiResponse struct {
	Result               int      `json:"result"`
	Message              string   `json:"message"`
	ServerList           []string `json:"serverlist"`
	ServerListWebSockets []string `json:"serverlist_websockets"`
}

func main() {
	if len(os.Args) < 3 {
		fmt.Println("Usage: cmservers <package> <output.go>")
		os.Exit(1)
	}

	pkg, output := os.Args[1], os.Args[2]

	res, err := http.Get(apiURL)

	if err != nil {
		log.Fatal(err)
	}

	defer res.Body.Close()

	if res.StatusCode != http.StatusOK {
		log.Fatal(res.Status)
	}

	apires := &apiResult{}
	dec := json.NewDecoder(res.Body)

	if err = dec.Decode(apires); err != nil {
		log.Fatal(err)
	}

	if apires.Response.Result != 1 {
		log.Fatalf(
			"server responded with invalid result %d, message: %s",
			apires.Response.Result,
			apires.Response.Message,
		)
	}

	f, err := os.Create(output)

	if err != nil {
		log.Fatal(err)
	}

	defer f.Close()

	tplvals := map[string]interface{}{
		"Package": pkg,
		"Servers": apires.Response.ServerList,
	}

	if err := tplCMServers.Execute(f, tplvals); err != nil {
		log.Fatal(err)
	}

	log.Printf("%s generated with %d CM servers", output, len(apires.Response.ServerList))
}
